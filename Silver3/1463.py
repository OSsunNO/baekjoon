# DP문제
# Bottom-Up 접근법 (각 경우를 모두 비교한 후 가장 작은 횟수를 값으로 할당하는 방식)
# 0으로 채워진 리스트를 입력값 +1 만큼 생성 (입력값으로 인덱스 맵핑을 하기 위해서)
# for구문을 통해 리스트에 [2]~[x]까지에 대한 최소 연산횟수를 차근차근 채워가는 방식
# 채워갈 때 우선적으로 1을 빼는 경우를 리스트의 값으로 채워주고 만약, 2로 나눠지는 값이면 1을 빼는 경우와 2로 나누는 경우 중 더 최소인 횟수를 값으로 저장
# i.e. a[i]==min(a[i],a[i//2]+1) -> 이미 앞선 코드에서 1을 빼는 경우를 리스트의 값으로 저장했으므로 a[i]와 a[i//2]+1이 비교 대상이 됨
# a[i//2]는 해당 값을 2로 나눴을 때의 최소연산횟수가 앞선 for 루프에서 저장됏을 것이므로 해당 횟수+1을 해주는 방식
x=int(input())
a = [0]*(x+1)
for i in range(2,x+1):
    a[i]=a[i-1]+1
    if(i%2==0):a[i]=min(a[i],a[i//2]+1)
    if(i%3==0):a[i]=min(a[i],a[i//3]+1)
print(a[x])

# Top-Down 접근법 (재귀 사용) - 코드 길이 길지만 훨씬 빠르고 메모리 사용도 적음
# 재귀함수 정의
# 입력 값이 1일 경우를 딕셔너리로 미리 정의해두고 함수 내부에서 dp.keys() 키워드를 통해 처리
# 입력값이 3과 2로 동시에 나눠지는 수일 때에는 재귀함수이름(n//3)+1과 재귀함수이름(n//2)+1 중 더 작은 값을 새로운 딕셔너리 요소로 추가
# 2로만 혹은 3으로만 나눠질 때는 1을 빼는 경우와 해당 경우를 비교해 더 작은 값을 새로운 딕셔너리 요소로 추가 - 역시나 값 비교 시 재귀함수에 해당 값을 넣고 +1을 한 후 비교
# 무엇으로도 나눠지지 않을 때에는 단순히 1을 빼서 새로운 딕셔너리 요소로 저장
# 마지막엔 return 입력받은 값
x=int(input())
dp={1:0}
def rec(n):
    if n in dp.keys():
        return dp[n]
    if (n%3==0) and (n%2==0):
        dp[n]=min(rec(n//3)+1, rec(n//2)+1)
    elif n%3==0:
        dp[n]=min(rec(n//3)+1, rec(n-1)+1)
    elif n%2==0:
        dp[n]=min(rec(n//2)+1, rec(n-1)+1)
    else:
        dp[n]=rec(n-1)+1
    return dp[n]
print(rec(x))