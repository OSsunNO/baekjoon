# 15 - 3*5/5*3
# 내 풀이
# 5의 배수와 3의 배수의 합으로 만들 수 없는 수의 경우 -1 출력
# 입력값을 각각 5와 3으로 나눈 몫을 변수에 저장하고 그만큼 for문 돌리기
# 리스트에 모든 경우의 수 추가 - 5와 3의 피연산자의 합으로 저장
# 만약, 리스트의 길이가 0이면 -1 출력(배수의 조합으로 생성 불가능)
# 경우의 수들 중 최솟값 출력
n = int(input())
a=[]
for i in range(n//5+1):
    for j in range(n//3+1):
        if(n == 5*i+3*j):
            a.append(i+j)
if(len(a)==0):print(-1)
else:print(min(a))

# 다른 풀이 - 그리디+다이나믹프로그래밍
# 출력할 변수의 값을 -1로 두고 시작
# 5의 배수와 3의 배수의 합인지를 판단하는 문제
# 이 때, 5의 배수일 때가 더 적은 개수의 봉지를 사용할 수 있으므로 5와의 곱에서 피연산자가 클수록 좋음
# 이 성질을 이용해서 리스트에 3과 5의 공배수인 15전까지 입력받은 값 - 3의 배수를 차례대로 넣어놓음
# 해당 리스트의 길이만큼 for구문을 돌려서 무게가 3kg인 봉지를 안쓰는 경우부터 최소공배수인 15전까지 전부 3kg 봉지를 사용하는 경우를 고려가능
# for구문이 돌아갈 때마다 무게가 3kg인 봉지를 1개씩 추가하는 알고리즘
# 사실 공배수의 경우가 없다면 5와 3을 바꿔서 해도 됨 - 어차피 다른 수들은 3과 5의 배수로 만들 수 있는 경우의 수가 1가지
# 15의 경우, 리스트에 3의 배수를 적용하면 봉지 개수가 3(5*3)이지만 5의 배수를 적용하면 봉지개수가 5(3*5)가 됨
k=int(input())
c=[k,k-3,k-6,k-9,k-12]
bag=-1
for i in range(len(c)):
    q=c[i]//5
    if q >= 0:
        r=c[i]%5
        if r == 0:
            bag=q+i
print(bag)

